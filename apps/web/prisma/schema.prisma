// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   Int
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       Int
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

// User model
model User {
    id            Int       @id @default(autoincrement())
    created_at    DateTime  @default(now())
    updated_at    DateTime  @updatedAt
    address       Address?
    email         String    @unique
    name          String?
    avatar_url    String?
    emailVerified DateTime?

    // Relationships
    generated_invoices Invoice[]      @relation("GeneratedInvoices")
    received_invoices  Invoice[]      @relation("ReceivedInvoices")
    clients            Client[]
    accounts           Account[]
    sessions           Session[]
    wallets            Wallet[]
    transactions       Transactions[]

    @@map("users")
}

// Client model
model Client {
    id                  Int                 @id @default(autoincrement())
    name                String
    email               String?
    address             Address?
    verification_status VerificationStatus  @default(PENDING)
    recipient_type      RecipientType       @default(BUSINESS)
    tax_number          String? // VAT/Tax ID
    created_at          DateTime            @default(now())
    updated_at          DateTime            @updatedAt
    is_archived         Boolean             @default(false)
    user_id             Int
    // Relationships
    user                User                @relation(fields: [user_id], references: [id])
    invoices            Invoice[]           @relation("ClientInvoices")
    transactions        Transactions[]
    fiat_accounts       FiatAccount[]
    blockchain_accounts BlockchainAccount[]
    ewallet_accounts    EwalletAccount[]

    @@index([user_id])
    @@map("clients")
}

model BlockchainAccount {
    id         String   @id @default(uuid())
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    address     String
    network     String
    environment String

    client_id Int
    client    Client @relation(fields: [client_id], references: [id])

    @@index([client_id])
    @@map("blockchain_accounts")
}

model FiatAccount {
    id         String   @id @default(uuid())
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    alias               String
    account_number      String
    routing_number      String
    account_type        FiatAccountType
    account_holder_name String
    bank_name           String
    bank_address        String?
    bank_city           String?
    bank_state          String?
    bank_zip            String?
    iso_currency        String
    transfer_method     TransferMethod?

    client_id Int
    client    Client @relation(fields: [client_id], references: [id])

    @@unique([client_id, alias])
    @@index([client_id])
    @@map("fiat_accounts")
}

model EwalletAccount {
    id         String   @id @default(uuid())
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    iso_currency     String
    mobile_number    String?
    ewallet_provider EwalletProvider?

    client_id Int
    client    Client @relation(fields: [client_id], references: [id])

    @@index([client_id])
    @@map("ewallet_accounts")
}

model Transactions {
    id         String   @id @default(uuid())
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    ts                     DateTime
    movement_type          TransactionMovementType
    tx_type                TransactionType
    blockchain_network     String
    blockchain_environment String
    blockchain_tx_id       String
    blockchain_tx_hash     String
    status                 TransactionStatus
    amount                 BigInt
    currency               String
    fee                    BigInt                  @default(0)
    reference              String?

    wallet_id String
    wallet    Wallet @relation(fields: [wallet_id], references: [id])

    sender_id Int
    sender    User @relation(fields: [sender_id], references: [id])

    recipient_id Int
    recipient    Client @relation(fields: [recipient_id], references: [id])

    @@index([sender_id])
    @@index([recipient_id])
    @@index([wallet_id])
    @@index([blockchain_network, blockchain_environment, blockchain_tx_id, blockchain_tx_hash])
    @@map("transactions")
}

// Invoice model
model Invoice {
    id             String   @id @default(uuid())
    invoice_number String   @unique
    po_number      String? // Purchase Order number
    currency       String // e.g., "PHP", "USD", "USDC"
    subtotal       Int // Sum of line items before tax
    tax_rate       Int      @default(0) // Tax rate as percentage (e.g., 12 for 12%)
    tax_amount     Int      @default(0) // Calculated tax amount
    total_amount   Int // Final amount including tax
    status         String   @default("Pending") // "Paid", "Pending", "Overdue", "Cancelled"
    due_date       DateTime
    description    String?
    notes          String?
    created_at     DateTime @default(now())
    updated_at     DateTime @updatedAt

    // Fields for invoice generation
    generator_id Int?
    generator    User?   @relation("GeneratedInvoices", fields: [generator_id], references: [id])
    client_id    Int?
    client       Client? @relation("ClientInvoices", fields: [client_id], references: [id])

    // Fields for received invoices
    receiver_id  Int?
    receiver     User?   @relation("ReceivedInvoices", fields: [receiver_id], references: [id])
    issuer_name  String? // Name of external invoice issuer
    issuer_email String? // Email of external invoice issuer

    // Relationship to line items
    lineItems LineItem[]

    @@index([generator_id])
    @@index([client_id])
    @@index([receiver_id])
    @@map("invoices")
}

// New LineItem model
model LineItem {
    id          Int      @id @default(autoincrement())
    description String
    quantity    Float
    unit_price  Float
    amount      Float // quantity * unitPrice
    created_at  DateTime @default(now())
    updated_at  DateTime @updatedAt

    // Relationship to invoice
    invoice_id String
    invoice    Invoice @relation(fields: [invoice_id], references: [id], onDelete: Cascade)

    @@index([invoice_id])
    @@map("line_items")
}

model Waitlist {
    id         Int      @id @default(autoincrement())
    contact    String
    name       String
    is_email   Boolean  @default(false)
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    @@map("waitlist")
}

// Address model
model Address {
    id         Int      @id @default(autoincrement())
    street     String
    city       String
    state      String?
    country    String
    zip_code   String?
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    // Relationships
    user_id   Int?    @unique // One-to-one with User
    user      User?   @relation(fields: [user_id], references: [id])
    client_id Int?    @unique // One-to-one with Client
    client    Client? @relation(fields: [client_id], references: [id])

    @@index([user_id])
    @@index([client_id])
    @@map("addresses")
}

// Wallet model
model Wallet {
    id                  String   @id @default(uuid())
    alias               String? // Custom name for the wallet
    key_id              String? // Key ID for the wallet
    address             String? // Blockchain address for crypto wallets
    network             String? // Network/chain for crypto wallets (e.g., "ETH", "SOL")
    network_environment String? // Mainnet, Testnet, etc.
    is_default          Boolean  @default(false)
    created_at          DateTime @default(now())
    updated_at          DateTime @updatedAt

    // Relationships
    user_id         Int
    user            User            @relation(fields: [user_id], references: [id], onDelete: Cascade)
    balances        WalletBalance[] @relation("WalletToBalance")
    main_balance_id String?
    main_balance    WalletBalance?  @relation("MainBalance", fields: [main_balance_id], references: [id])
    Transactions    Transactions[]

    @@unique([user_id, alias])
    @@unique([address, network])
    @@index([user_id])
    @@map("wallets")
}

// WalletBalance model
model WalletBalance {
    id         String   @id @default(uuid())
    address    String
    amount     BigInt   @default(0)
    currency   String // e.g., "ETH", "USDC", "USD"
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    // Relationships
    wallet_id        String
    wallet           Wallet   @relation("WalletToBalance", fields: [wallet_id], references: [id], onDelete: Cascade)
    main_for_wallets Wallet[] @relation("MainBalance")

    @@unique([wallet_id, currency])
    @@index([wallet_id])
    @@map("wallet_balances")
}

enum TransactionType {
    ON_CHAIN_TRANSFER
    OFF_CHAIN_TRANSFER
    ON_RAMP
    OFF_RAMP
}

enum TransactionStatus {
    PENDING
    COMPLETED
    FAILED
}

enum TransactionMovementType {
    IN
    OUT
}

enum VerificationStatus {
    PENDING
    VERIFIED
    REJECTED
}

enum RecipientType {
    BUSINESS
    INDIVIDUAL
}

enum FiatAccountType {
    CHECKING
    SAVINGS
}

enum TransferMethod {
    PH_PESONET
    PH_INSTAPAY
}

enum EwalletProvider {
    PH_GCASH
    PH_MAYA
    PH_COINS_PH
}
