// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   Int
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       Int
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// User model
model User {
    id            Int       @id @default(autoincrement())
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    address       Address?
    email         String    @unique
    name          String?
    avatarUrl     String?
    emailVerified DateTime?

    // Relationships
    generatedInvoices Invoice[] @relation("GeneratedInvoices")
    receivedInvoices  Invoice[] @relation("ReceivedInvoices")
    clients           Client[]
    Account           Account[]
    Session           Session[]
    wallets           Wallet[]
}

// Client model
model Client {
    id        Int      @id @default(autoincrement())
    name      String
    email     String?
    address   Address?
    taxNumber String? // VAT/Tax ID
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    userId   Int
    // Relationships
    user     User      @relation(fields: [userId], references: [id])
    invoices Invoice[] @relation("ClientInvoices")

    @@index([userId])
}

// Invoice model
model Invoice {
    id            String   @id @default(uuid())
    invoiceNumber String   @unique
    poNumber      String? // Purchase Order number
    currency      String // e.g., "PHP", "USD", "USDC"
    subtotal      Float // Sum of line items before tax
    taxRate       Float    @default(0) // Tax rate as percentage (e.g., 12 for 12%)
    taxAmount     Float    @default(0) // Calculated tax amount
    totalAmount   Float // Final amount including tax
    status        String   @default("Pending") // "Paid", "Pending", "Overdue", "Cancelled"
    dueDate       DateTime
    description   String?
    notes         String?
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    // Fields for invoice generation
    generatorId Int?
    generator   User?   @relation("GeneratedInvoices", fields: [generatorId], references: [id])
    clientId    Int?
    client      Client? @relation("ClientInvoices", fields: [clientId], references: [id])

    // Fields for received invoices
    receiverId  Int?
    receiver    User?   @relation("ReceivedInvoices", fields: [receiverId], references: [id])
    issuerName  String? // Name of external invoice issuer
    issuerEmail String? // Email of external invoice issuer

    // Relationship to line items
    lineItems LineItem[]

    @@index([generatorId])
    @@index([clientId])
    @@index([receiverId])
}

// New LineItem model
model LineItem {
    id          Int      @id @default(autoincrement())
    description String
    quantity    Float
    unitPrice   Float
    amount      Float // quantity * unitPrice
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Relationship to invoice
    invoiceId String
    invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

    @@index([invoiceId])
}

model Waitlist {
    id        Int      @id @default(autoincrement())
    contact   String
    name      String
    isEmail   Boolean  @default(false)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// Address model
model Address {
    id        Int      @id @default(autoincrement())
    street    String
    city      String
    state     String?
    country   String
    zipCode   String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relationships
    userId   Int?    @unique // One-to-one with User
    user     User?   @relation(fields: [userId], references: [id])
    clientId Int?    @unique // One-to-one with Client
    client   Client? @relation(fields: [clientId], references: [id])

    @@index([userId])
    @@index([clientId])
}

// Wallet model
model Wallet {
    id                 String   @id @default(uuid())
    alias              String? // Custom name for the wallet
    keyId              String? // Key ID for the wallet
    address            String? // Blockchain address for crypto wallets
    network            String? // Network/chain for crypto wallets (e.g., "ETH", "SOL")
    networkEnvironment String? // Mainnet, Testnet, etc.
    isDefault          Boolean  @default(false)
    createdAt          DateTime @default(now())
    updatedAt          DateTime @updatedAt

    // Relationships
    userId        Int
    user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
    balances      WalletBalance[] @relation("WalletToBalance")
    mainBalanceId String?
    mainBalance   WalletBalance?  @relation("MainBalance", fields: [mainBalanceId], references: [id])

    @@unique([userId, alias])
    @@unique([address, network])
    @@index([userId])
}

// WalletBalance model
model WalletBalance {
    id        String   @id @default(uuid())
    address   String
    amount    BigInt   @default(0)
    currency  String // e.g., "ETH", "USDC", "USD"
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relationships
    walletId       String
    wallet         Wallet   @relation("WalletToBalance", fields: [walletId], references: [id], onDelete: Cascade)
    mainForWallets Wallet[] @relation("MainBalance")

    @@unique([walletId, currency])
    @@index([walletId])
}
